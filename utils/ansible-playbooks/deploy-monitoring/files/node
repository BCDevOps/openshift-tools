#!/usr/bin/env bash

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch the error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail
# Turn on traces, useful while debugging but commented out by default
# set -o xtrace

# Print a backtrace on error
# https://github.com/ab/bin/blob/master/bash-backtrace.sh
bash_backtrace() {
    # Return value of command that caused error
    local RET=$?
    # Frame counter
    local I=0
    # backtrace layers
    local FRAMES=${#BASH_SOURCE[@]}

    # Restore STDOUT and STDERR as they might be in unknown states due to catching
    # an error in the middle of a command
    exec 1>&3 2>&4

    echo "Traceback (most recent call last):"

    for ((FRAME=FRAMES-2; FRAME >= 0; FRAME--)); do
        local LINENO=${BASH_LINENO[FRAME]}

        # Location of error
        echo "  File ${BASH_SOURCE[FRAME+1]}, line ${LINENO}, in ${FUNCNAME[FRAME+1]}"

        # Print the error line, with preceding whitespace removed
        echo "$(sed -n "${LINENO}s/^[   ]*/    /p" "${BASH_SOURCE[FRAME+1]}")"
    done

    echo "Exiting with status ${RET}"
    exit "${RET}"
}

# Copy STDOUT and STDERR so they can be restored later
exec 3>&1 4>&2
# Trap script errors and print some helpful debug info
trap bash_backtrace ERR

# Standardize the date stamps output
function datestamp () {
  date "+%F %H:%M:%S"
}

# Check Docekr is running
echo -n "$(datestamp) Docker Deamon Status: "
if ! systemctl is-active docker.service
then
  echo "$(datestamp) ERROR: Docker is not running"
  # Other checks depend on Docker running, exit out
  exit 1
fi

# Check Docker Data usage
echo -n "$(datestamp) Docker Data Space is: "
SPACE=$(echo $(echo \"$(docker info 2>/dev/null | awk '/Data Space Available/ {print $4}') / $(docker info 2>/dev/null | awk '/Data Space Total/ {print $4}')\" | bc -l))
echo "$SPACE = $(echo 'scale=2;' $SPACE '*' 100 | bc -l)% free"
FREE=$(echo $SPACE '>' 0.15 | bc -l)
if [ "$FREE" -lt 1 ]
then
  echo "$(datestamp) ERROR: Low Docker Data Space"
fi

# Check Docker Metadata Usage
echo -n "$(datestamp) Docker Metadata Space is: "
SPACE=$(echo $(echo \"$(docker info 2>/dev/null | awk '/Metadata Space Available/ {print $4}') / $(docker info 2>/dev/null | awk '/Metadata Space Total/ {print $4}')\" | bc -l))
echo "$SPACE = $(echo 'scale=2;' $SPACE '*' 100 | bc -l)% free"
FREE=$(echo $SPACE '>' 0.15 | bc -l)
if [ "$FREE" -lt 1 ]
then
  echo "$(datestamp) ERROR: Low Docker Metadata Space"
fi

# Check for local volume count
# May fail on masters that have zero, so ||true
VOLS=$(mount|grep -c openshift.local.volumes||true)
echo "$(datestamp) Pod volumes: $VOLS"
if [ "$VOLS" -gt "1000" ]
then
  echo "$(datestamp) ERROR: Too many volumes"
fi

# Check Node service
echo -n "$(datestamp) OpenShift Node Deamon Status: "
if ! systemctl is-active atomic-openshift-node.service
then
  echo "$(datestamp) ERROR: OpenShift Node is not running"
fi

# Check OpenVSwitch service
echo -n "$(datestamp) OpenVSwitch Deamon Status: "
if ! systemctl is-active openvswitch.service
then
  echo "$(datestamp) ERROR: OpenVSwitch is not running"
fi

